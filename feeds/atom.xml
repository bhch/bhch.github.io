<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>blog of bhch</title><link href="https://bhch.github.io/" rel="alternate"></link><link href="https://bhch.github.io/feeds/atom.xml" rel="self"></link><id>https://bhch.github.io/</id><updated>2017-09-16T00:00:00+05:30</updated><entry><title>Python testing - Introduction to mocking</title><link href="https://bhch.github.io/posts/2017/09/python-testing-introduction-to-mocking/" rel="alternate"></link><updated>2017-09-10T00:00:00+05:30</updated><author><name>bhch</name></author><id>tag:bhch.github.io,2017-09-10:posts/2017/09/python-testing-introduction-to-mocking/</id><summary type="html">&lt;h1 id="what-is-mocking"&gt;What is mocking?&lt;/h1&gt;
&lt;p&gt;Let me try and explain what mocking is and when you need it, with an example &amp;mdash;&lt;/p&gt;
&lt;p&gt;Suppose you have a web app where users can sign up. When a user signs up, 
your app automatically sends them an email asking them to verify their email 
address. The workflow would look like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;User sees the page&lt;/li&gt;
&lt;li&gt;User submits the sign up form&lt;/li&gt;
&lt;li&gt;Check if credentials are valid&lt;/li&gt;
&lt;li&gt;Create the user if valid OR show error if invalid&lt;/li&gt;
&lt;li&gt;Send email if user is created&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, your app probably has a few functions (or classes) for doing specific tasks 
such as &lt;em&gt;validating&lt;/em&gt;, &lt;em&gt;saving to database&lt;/em&gt;, &lt;em&gt;sending email&lt;/em&gt;, and a main &lt;em&gt;sign up&lt;/em&gt;
function to render the form. etc. &lt;/p&gt;
&lt;p&gt;Let's say the function that handles sign ups, and the function that sends email 
look roughly like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
def sign_up(username, password):
    """The sign up function, called when a user submits form"""

    # check if user credentials are valid

    # save user

    # send email
    send_verification_mail(emal=user.email)

def send_verification_mail(email):
    # compose a mail and send
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Say you want to test the &lt;code&gt;sign_up&lt;/code&gt; function to see if the sign up workflow behaves
as expected, but you don't want to trigger sending emails. You might be creating 
users many times during the tests. So, sending emails every time can be 
a bad idea because it can slow down your tests. Or if the mail server returns 
any error, your tests would fail (of course, you can handle those errors, but 
for the sake of this example, bear with me).&lt;/p&gt;
&lt;p&gt;Since, the &lt;code&gt;sign_up&lt;/code&gt; function calls the &lt;code&gt;send_verification_mail&lt;/code&gt; function 
from within, it's guaranteed that if you test &lt;code&gt;sign_up&lt;/code&gt; function, 
you will trigger sending email.&lt;/p&gt;
&lt;p&gt;This gives rise to the question: How can I test &lt;code&gt;sign_up&lt;/code&gt; function without 
calling &lt;code&gt;send_verification_mail&lt;/code&gt; function? &lt;/p&gt;
&lt;p&gt;This is where mocking comes in. Mocking means you can create a &lt;em&gt;fake&lt;/em&gt; function 
to replace &lt;code&gt;send_verifiation_mail&lt;/code&gt; in your tests. That's it.&lt;/p&gt;
&lt;h1 id="a-simple-example"&gt;A Simple example&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you're using Python 2.7 or any version &amp;lt; 3.3, you'll need to install the 
&lt;code&gt;mock&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sh
$ pip install mock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For Python &amp;gt;= 3.3, the &lt;code&gt;mock&lt;/code&gt; is included in the standard library and 
can be imported as &lt;code&gt;unittest.mock&lt;/code&gt;. &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;First create a file called &lt;code&gt;main.py&lt;/code&gt;. Our code will live in this.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
# main.py

import time

def long_process():
    # to emulate a long running 
    # process, we'll use time.sleep
    time.sleep(5)
    return True

def call_long_process():
    long_process()
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;main.py&lt;/code&gt;, we have a function called &lt;code&gt;long_process()&lt;/code&gt; which sleeps for &lt;code&gt;5&lt;/code&gt; seconds 
and returns &lt;code&gt;True&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;There's another function in &lt;code&gt;main.py&lt;/code&gt; called &lt;code&gt;call_long_process()&lt;/code&gt;. It just calls 
the &lt;code&gt;long_process_function()&lt;/code&gt; and returns &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, let's write some tests for the above code in a file called &lt;code&gt;tests.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# tests.py

from unittest import TestCase
from mock import patch # for Python &amp;gt;= 3.3 use unittest.mock

from main import long_process, call_long_process


class MainTests(TestCase):
    """Tests for `long_process`"""

    def test_long_process(self):
        # test if `long_process` returns true

        self.assertTrue(long_process())

    def test_call_long_process(self):
        # test if `call_long_process`
        # actually calls `long_process`

        self.assertTrue(call_long_process())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;tests.py&lt;/code&gt;, we are testing that &lt;code&gt;long_process()&lt;/code&gt; function works correctly and 
it should return &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We're also testing that &lt;code&gt;call_long_process()&lt;/code&gt; function calls the &lt;code&gt;long_process()&lt;/code&gt;
function.&lt;/p&gt;
&lt;p&gt;Run the tests:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sh
$ python -m unittest tests

# Output

..
----------------------------------------------------------------------
Ran 2 test in 10.004s

OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our test passed but it took a long time. In our tests, the &lt;code&gt;long_process()&lt;/code&gt; function 
is being called twice - once in &lt;code&gt;test_long_process&lt;/code&gt; and again in &lt;code&gt;test_call_long_process&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the second test, we only want to test if &lt;code&gt;call_long_process()&lt;/code&gt; actually calls 
&lt;code&gt;long_process()&lt;/code&gt;. We don't care it &lt;code&gt;long_process()&lt;/code&gt; works properly or not, because 
we have tested that in the first test. So, there's no point in waiting 5 more seconds 
for the process to finish.&lt;/p&gt;
&lt;p&gt;Let's patch the &lt;code&gt;long_process()&lt;/code&gt; function in our second test.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
# tests.py

class MainTests(TestCase):
    # ...
    # same code as above ...

    def test_call_long_process(self):
        with patch('main.long_process', return_value=True) as mock_process:

            # test the return value of `call_long_process` 
            self.assertTrue(call_long_process())

            # test if `call_long_process`
            # issues a call to `long_process`
            mock_process.assert_called_once()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above, we've patched the &lt;code&gt;long_process()&lt;/code&gt; function in the second test. We've called 
the mock object &lt;code&gt;mock_process&lt;/code&gt;. We test that the return value of &lt;code&gt;call_long_process()&lt;/code&gt; 
is &lt;code&gt;True&lt;/code&gt;, and we also test that it actually calls &lt;code&gt;long_process()&lt;/code&gt;. But since, 
we've created a mock object for it, we have to test if &lt;code&gt;mock_process&lt;/code&gt; is called or 
not. That would tell us if &lt;code&gt;call_long_process()&lt;/code&gt; issued a call, or not.&lt;/p&gt;
&lt;p&gt;Let's run our tests:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sh
$ python -m unittest tests

# Output

..
----------------------------------------------------------------------
Ran 2 test in 5.003s

OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It worked! This time it took only 5 seconds to run all the tests. This means that 
the &lt;code&gt;long_process()&lt;/code&gt; was actually called only once. &lt;/p&gt;
&lt;p&gt;To execute our tests even faster, we can keep the tests for &lt;code&gt;long_process()&lt;/code&gt; in a 
separate file and run them only when we have to. &lt;/p&gt;
&lt;h1 id="thats-it"&gt;That's it&lt;/h1&gt;
&lt;p&gt;In this post, I covered what mocking is and when you need it. I've also shown a 
very basic example of getting started with mocking.&lt;/p&gt;
&lt;p&gt;In the next post, I'll write about how you can mock HTTP requests made using the 
&lt;code&gt;requests&lt;/code&gt; library.&lt;/p&gt;</summary><category term="python"></category><category term="mock"></category><category term="unittest"></category></entry><entry><title>How to integrate haystack search with Django admin</title><link href="https://bhch.github.io/posts/2017/08/how-to-integrate-haystack-search-with-django-admin/" rel="alternate"></link><updated>2017-08-28T00:00:00+05:30</updated><author><name>bhch</name></author><id>tag:bhch.github.io,2017-08-28:posts/2017/08/how-to-integrate-haystack-search-with-django-admin/</id><summary type="html">&lt;p&gt;Recently, I had to integrate Haystack with Django admin so as to be able to 
perform a full text search just via the admin. Looking around for resources on the 
internet, I came across &lt;a href="http://django-haystack.readthedocs.io/en/v2.4.1/admin.html"&gt;this page&lt;/a&gt; in Haystack's docs. Turns out Haystack 
has provided a solution to ease the integration of Haystack with Django admin.&lt;/p&gt;
&lt;p&gt;Well, sort of. You see, the solution they've provided in the docs is only partial.
You can do exactly what the docs instruct, yet the example won't work. &lt;/p&gt;
&lt;p&gt;The solution is to set the &lt;a href="https://docs.djangoproject.com/en/1.11/ref/contrib/admin/#django.contrib.admin.ModelAdmin.search_fields"&gt;&lt;code&gt;search_fields&lt;/code&gt;&lt;/a&gt; attribute in your admin class. 
The value of &lt;code&gt;search_fields&lt;/code&gt; can be set to any field that is present in your model.
Haystack's &lt;code&gt;SearchModelAdmin&lt;/code&gt; class will override it and will search your 
search index's &lt;code&gt;text&lt;/code&gt; field. &lt;/p&gt;
&lt;p&gt;Below is an example that would provide a little more illustration to the solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
# models.py

class Article(models.Model):
    title = models.CharField(max_length=100)
    body = models.TextField() # we want to search this field
    pub_date = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-pub_date'] # show newest articles first
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm not gonna show how to set up Haystack search index. This post is not about that. 
Hopefully, you've already done that. If not, you can read Haystack's &lt;a href="http://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html#handling-data"&gt;docs&lt;/a&gt; about 
that.&lt;/p&gt;
&lt;p&gt;Let's see the admin:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
# admin.py

from django.contrib import admin
from haystack.admin import SearchModelAdmin
from .models import Article


class ArticleAdmin(SearchModelAdmin):
    # set the search_fields attribute to a field present in Article
    search_fields = ('title',) # or ('body',) it doesn't really matter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have inherited our admin class from &lt;code&gt;SearchModelAdmin&lt;/code&gt; class provided 
by Haystack. This will take the search query argument, search the index, then 
return the results.&lt;/p&gt;
&lt;p&gt;That's it! Try searching for something in Django admin, it should be working 
(if it's not, have you updated or created a search index yet?).&lt;/p&gt;
&lt;h3 id="heads-up"&gt;Heads up&lt;/h3&gt;
&lt;p&gt;There are two downsides of integrating Haystack search with Django admin.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; The checkboxes on the left of the changelist page table will not appear in the
search results. I don't find this a big issue, though. If a find a solution to 
this, I will post it here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; The search results will not be ordered as expected. For example, we've 
ordered the Articles by &lt;code&gt;pub_date&lt;/code&gt; in reverse order so that newest articles 
appear first. But this ordering won't apply to haystack's search results. 
They will appear, in this case, as oldest first. &lt;/p&gt;
&lt;p&gt;There's a workaround for that. You might not like it. I don't like. Having said 
that, I used that workaround for the project since I was on a deadline. And now 
I'm too lazy to look for another solutions. Anyways, here it is:&lt;/p&gt;
&lt;p&gt;Firstly, make sure that you've included the model field in your haystack search index 
class that you want to use for ordering. So in this case, that field is &lt;code&gt;pub_date&lt;/code&gt;. 
What I mean is, &lt;strong&gt;you have to included &lt;code&gt;pub_date&lt;/code&gt; in your search index&lt;/strong&gt; if you want 
to use it for ordering. Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
class ArticleIndex(indexes.SearchIndex, indexes.Indexable):
    text = indexes.CharField(document=True, use_template=True)
    pub_date = indexes.DateTimeField(model_attr='pub_date')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now copy the &lt;code&gt;haystack/admin.py&lt;/code&gt; file to your project or app's directory. Save it 
as &lt;code&gt;search_admin.py&lt;/code&gt;. Open it in a text editor. You'll see a class defined as 
&lt;code&gt;SearchChangeList&lt;/code&gt;. You'll have to change a line inside it. Find the following 
line in that class:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
sqs = SearchQuerySet(self.haystack_connection).models(self.model).auto_query(request.GET[SEARCH_VAR]).load_all()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, all you have to do is append &lt;code&gt;.order_by('field_name')&lt;/code&gt; to that line. In this case, 
&lt;code&gt;.order_by('-pub_date')&lt;/code&gt; (&lt;strong&gt;"&lt;code&gt;-&lt;/code&gt;"&lt;/strong&gt; means reverse ordering). Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
sqs = SearchQuerySet(self.haystack_connection
    ).models(self.model
    ).auto_query(request.GET[SEARCH_VAR]
    ).load_all().order_by('-pub-date')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, in your &lt;code&gt;admin.py&lt;/code&gt; file, you've to import the &lt;code&gt;SearchModelAdmin&lt;/code&gt; from this file, 
instead of from &lt;code&gt;haystack.admin&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
from haystack.admin import SearchModelAdmin # Replace this

from search_admin import SearchModelAdmin # with this
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know, this workaround is really ugly. The more preferable way would be to 
override the code, instead of copying  and changing it. Believe me, I tried that. 
But if you go through the source code in &lt;code&gt;haystack/admin.py&lt;/code&gt; file, you'll see 
overriding is not possible. Well, it is possible, but, it would still be ugly. 
Just go through the code, you'll see. If you have a better workaround, I'd love to know. &lt;/p&gt;</summary><category term="python"></category><category term="django"></category><category term="haystack"></category></entry><entry><title>Understanding Tornado fundamentals</title><link href="https://bhch.github.io/posts/2017/06/understanding-tornado-fundamentals/" rel="alternate"></link><updated>2017-09-16T00:00:00+05:30</updated><author><name>bhch</name></author><id>tag:bhch.github.io,2017-06-23:posts/2017/06/understanding-tornado-fundamentals/</id><summary type="html">&lt;p&gt;Tornado's documentation is very feeble, or at least I found it so. It doesn't 
explain some things in depth. Being new to async programming model, I found many things 
quite difficult to understand. The documentation also lacks a good tutorial, like 
the Django's documnetation has an excellent Polls tutorial which explains almost 
everything that one needs to get started with Django.&lt;/p&gt;
&lt;p&gt;I feel I should share what I learned in the hope that it might help somebody. 
These are the things I think if were present in the documentation, would have 
made my life much easier.&lt;/p&gt;
&lt;h1 id="can-tornado-make-blocking-code-non-blocking"&gt;Can Tornado make blocking code non-blocking?&lt;/h1&gt;
&lt;p&gt;No, it can't. Tornado isn't magic. For example, you can't use &lt;code&gt;time.sleep&lt;/code&gt; in your 
Tornado app and expect that Tornado will pause the code execution for one particular 
client while serving other clients. Tornado is a single threaded server. And 
&lt;code&gt;time.sleep&lt;/code&gt; blocks the thread. So, if you use &lt;code&gt;time.sleep&lt;/code&gt;, for example, to simulate 
a slow network connection, the whole server will block.&lt;/p&gt;
&lt;p&gt;Consider this code: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
import time

class BlockingHandler(web.RequestHandler):
    def get(self):
        time.sleep(10) 
        self.write("Hello 1")

class NonBlockingHandler(web.RequestHandler):
    def get(self):
        self.write("Hello 2")
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is pretty obvious: &lt;code&gt;BlockingHandler&lt;/code&gt; will wait 10 seconds before returning 
a response. &lt;code&gt;NonBlockingHandler&lt;/code&gt; will return the response as soon as it gets a request.&lt;/p&gt;
&lt;p&gt;So, you might think that if you make a request to &lt;code&gt;BlockingHandler&lt;/code&gt; and then make 
another request to &lt;code&gt;NonBlockingHandler&lt;/code&gt;, you'll get a response from &lt;code&gt;NonBlockingHander&lt;/code&gt; 
first and then 10 seconds later, you'll get a response from &lt;code&gt;BlockingHandler&lt;/code&gt;. 
&lt;strong&gt;But that's not the case.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Try it yourself: make a request to &lt;code&gt;BlockingHandler&lt;/code&gt; from your browser. Then open a new tab
and make a request to &lt;code&gt;NonBlockingHandler&lt;/code&gt;. You'll notice that even though the 
&lt;code&gt;NonBlockingHandler&lt;/code&gt; doesn't block anywhere, you're not getting a response for it.&lt;/p&gt;
&lt;p&gt;But as soon as the 10 seconds pass, you'll get the response for both &lt;code&gt;BlockingHandler&lt;/code&gt; 
and &lt;code&gt;NonBlockingHandler&lt;/code&gt;. This is happening because the &lt;code&gt;BlockingHandler&lt;/code&gt; blocks 
the event loop. Therefore, Tornado can't accept other requests as long as this 
handler is running. That is why you won't get a response for &lt;code&gt;NonBlockingHandler&lt;/code&gt; 
if &lt;code&gt;BlockingHandler&lt;/code&gt; is already running.&lt;/p&gt;
&lt;p&gt;This is what will happen if you try to query a database synchronously. It will 
block the server &lt;strong&gt;for all the clients&lt;/strong&gt; and &lt;strong&gt;all the handlers&lt;/strong&gt; until the query finishes.&lt;/p&gt;
&lt;h1 id="how-coroutines-make-writing-async-code-easier-than-callbacks"&gt;How coroutines make writing async code easier than callbacks?&lt;/h1&gt;
&lt;p&gt;With callbacks, you need to write &lt;em&gt;extra&lt;/em&gt; code that you won't even require if 
you use coroutines. Thus, code becomes shorter and more readable. Other than that, 
coroutines won't automatically make your code async. Again, they just make the 
code shorter and easier to maintain and debug. In smaller projects, this might not 
seem a big advantage, but in bigger projects, it's a godsend.&lt;/p&gt;
&lt;p&gt;Let's say we want do the following things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dowload a page asynchronously from a given url&lt;/li&gt;
&lt;li&gt;Do some processing on the downloaded page&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;First, let's see the code using callbacks:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
from tornado.httpclient AsyncHttpClient

def fetch_url():
    url = 'http://example.com'
    http_client = AsyncHttpClient()
    http_client.fetch(url, callback=process_result)

def process_result(result):
    # do something with result
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see we can't process the result in the &lt;code&gt;fetch_url&lt;/code&gt; function (sure, you can
move the &lt;code&gt;process_result&lt;/code&gt; function inside &lt;code&gt;fetch_url&lt;/code&gt; but still it's a different 
function). You need to create a separate function to process the result. A separate 
function is required which will be called when the page downloads.&lt;/p&gt;
&lt;p&gt;Now let's do the same thing using coroutines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
from tornado.http client import AsyncHttpClient
from tornado import gen

@gen.coroutine
def fetch_url_and_process_result():
    url = 'http://example.com'
    http_client = AsyncHttpClient()
    result = yield http_client(url)
    # do something with the result
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is shorter and much straight forward. The way it works is that the coroutine 
pauses every time it sees the &lt;code&gt;yield&lt;/code&gt; statement. Then you need to call the coroutine's
&lt;code&gt;next()&lt;/code&gt; method to execute the &lt;code&gt;yield&lt;/code&gt; statement and the code after that. So, when 
the page downloads, Tornado will call the &lt;code&gt;next()&lt;/code&gt; on &lt;code&gt;fetch_url_and_process_result&lt;/code&gt;
and it will execute the &lt;code&gt;yield&lt;/code&gt; statement and the code after that. So, all the 
processing can be done below the &lt;code&gt;yield&lt;/code&gt; statement. No need for a separate function.
More is explained below in the &lt;code&gt;gen.coroutine&lt;/code&gt; section.&lt;/p&gt;
&lt;p&gt;This example is a very simple use case. Consider this: let's say you need to do 
many different operations on the result. If you're using callbacks, you'll need 
to create as many functions as many time you need to process the result.&lt;/p&gt;
&lt;p&gt;But with coroutines, you can do all the operations in one single function (coroutine).&lt;/p&gt;
&lt;h1 id="what-are-futures"&gt;What are Futures?&lt;/h1&gt;
&lt;p&gt;A Future is a &lt;em&gt;promise&lt;/em&gt; to return the result when it's available. For example, 
if you request a web page using Tornado's &lt;code&gt;httpclient.AsyncHttpClient&lt;/code&gt;, it will 
return a &lt;em&gt;Future&lt;/em&gt; - an instance of Tornado's &lt;code&gt;Future&lt;/code&gt; class - while it waits for 
the web page to load. As soon as the web page is loaded, Tornado will set the 
result on the &lt;code&gt;Future&lt;/code&gt; instance. Then, if you yield the Future object, you will 
get the result. &lt;/p&gt;
&lt;p&gt;For the most part, you don't need to worry about Futures. But sometimes, you 
might need to return a Future manually from functions/coroutines. But that's a 
somewhat advanced usage. &lt;a href="https://github.com/tornadoweb/tornado/blob/master/demos/chat/chatdemo.py#L38-L54"&gt;This example code&lt;/a&gt; from Tornado's
GitHub repo might be helpful for that. &lt;/p&gt;
&lt;h4 id="summary"&gt;&lt;strong&gt;Summary:&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Yielding a Future returns it's result&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="gencoroutine"&gt;&lt;code&gt;gen.coroutine&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;gen.coroutine&lt;/code&gt; is a decorator that you can use with your functions or coroutines 
to avoid callback based programming. But its real use case is if you're calling a 
function/coroutine that returns a Future, you should decorate the caller with 
&lt;code&gt;gen.coroutine&lt;/code&gt; to make things work as expected.&lt;/p&gt;
&lt;p&gt;See the code below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
def return_future():
    """This returns a Future object"""
    f = Future()
    return f

@gen.coroutine
def process_result():
    future = return_future()
    result = yield future
    # do something with the result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code explanation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;gen.coroutine&lt;/code&gt; automatically calls &lt;code&gt;process_result&lt;/code&gt;'s &lt;code&gt;next()&lt;/code&gt;method 
 (to start the generator).&lt;/li&gt;
&lt;li&gt;Then it puts this &lt;code&gt;process_result&lt;/code&gt; coroutine to a &lt;em&gt;"waiting list"&lt;/em&gt; until 
 &lt;code&gt;future&lt;/code&gt; has a result. There might be some other code that's
  responsible for setting the result on the &lt;code&gt;future&lt;/code&gt;, I've not shown that code. 
  So, no need to dwell into that. &lt;/li&gt;
&lt;li&gt;When the result is set on the &lt;code&gt;future&lt;/code&gt;, it calls the &lt;code&gt;next()&lt;/code&gt; method of 
 &lt;code&gt;process_result&lt;/code&gt; again which executes the &lt;code&gt;result = yield future&lt;/code&gt; statement and 
 sets &lt;code&gt;result&lt;/code&gt; variable to &lt;code&gt;future&lt;/code&gt;'s result.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you don't decorate the &lt;code&gt;process_result&lt;/code&gt; with &lt;code&gt;gen.coroutine&lt;/code&gt; you will need to 
use callbacks and the code becomes a mess. Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
def return_future(callback):
    f = Future()
    f.add_done_callback(callback)
    return f

def get_future():
    future = return_future(callback=process_result)


def process_result(future):
    result = future.result()
    # do something with the result
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="gencoroutine-decorated-functions-will-return-a-future-automatically"&gt;&lt;strong&gt;&lt;code&gt;gen.coroutine&lt;/code&gt; decorated functions will return a Future automatically&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;If you decorate a function/coroutine using &lt;code&gt;gen.coroutine&lt;/code&gt;, a Future object 
will be returned automatically.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
@gen.coroutine
def my_func():
    pass # return nothing

x = my_func()

print type(x)
# OUTPUTS:  tornado.concurrent.Future
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See? Even if you don't return anything, &lt;code&gt;gen.coroutine&lt;/code&gt; will return a Future.
So, if you return a Future from a decorated function, &lt;code&gt;gen.coroutine&lt;/code&gt; will 
wrap that Future object inside another Future object, which is not what you want.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
@gen.coroutine
def my_func():
    f = Future()
    return f
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In above code, you're returning a Future object, but that is not what you'll get. 
You'll get this instead - &lt;code&gt;Future(f)&lt;/code&gt; - a Future within a Future. Because of this,
you'll have to &lt;code&gt;yield&lt;/code&gt; twice to get the result.&lt;/p&gt;
&lt;p&gt;If you're returning a Future manually, you don't need to decorate the function.&lt;/p&gt;
&lt;h4 id="calling-a-gencoroutine-decorated-function"&gt;&lt;strong&gt;Calling a &lt;code&gt;gen.coroutine&lt;/code&gt; decorated function&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;If you're calling a &lt;code&gt;gen.coroutine&lt;/code&gt; decorated function/coroutine, you must decorate 
the caller with &lt;code&gt;gen.coroutine&lt;/code&gt; too. And you must use the &lt;code&gt;yield&lt;/code&gt; keyword in the caller.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
@gen.coroutine
def do_nothing():
    pass

@gen.coroutine
def do_something():
    result = yield do_nothing()
    if result is not None:
        print result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It makes perfect sense to use &lt;code&gt;yield&lt;/code&gt; keyword in the caller (above, &lt;code&gt;do_something&lt;/code&gt;)
because &lt;code&gt;gen.coroutine&lt;/code&gt; will return a Future. And to get it's result, you need to 
yield it. &lt;/p&gt;
&lt;h4 id="summary_1"&gt;&lt;strong&gt;Summary:&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;gen.coroutine&lt;/code&gt; decorated functions will automatically retrurn a Future&lt;/li&gt;
&lt;li&gt;You don't need to use callbacks if you're using coroutines&lt;/li&gt;
&lt;li&gt;If a function/coroutine is calling another coroutine decorated with &lt;code&gt;gen.coroutine&lt;/code&gt;,
 it must also be decorated with &lt;code&gt;gen.coroutine&lt;/code&gt; and must use the &lt;code&gt;yield&lt;/code&gt; keyword&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="webasynchronous"&gt;&lt;code&gt;web.asynchronous&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;This decorator is meant to be used on methods of Tornado's &lt;code&gt;web.RequestHandler&lt;/code&gt;, namely: &lt;code&gt;get&lt;/code&gt;, 
&lt;code&gt;post&lt;/code&gt; etc. Since all Tornado handlers are synchronous, you can't perform any async 
operations inside them. As soon as the method ends or returns, the request is considered 
finished.&lt;/p&gt;
&lt;p&gt;Look at the following code example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
class MainHandler(web.RequestHandler):
    def get(self):
        http = AsyncHttpHandler()
        http.fetch("example.com", callback=self.on_response)

    def on_response(self, response):
        # do something with response ...
        self.write(response)
        self.finish()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code aims to do the following things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Asynchronously fetch "example.com" from &lt;code&gt;get&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;Keep the client waiting unless url is fetched&lt;/li&gt;
&lt;li&gt;When url is fetched, call &lt;code&gt;on_response&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;Perform some operations on the response (fetched url)&lt;/li&gt;
&lt;li&gt;Return the response to the client&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But this won't work. Because &lt;code&gt;get&lt;/code&gt; is synchronous by default, as soon as this method 
ends, the request is considered finished. Tornado won't keep the client in the waiting 
list while the url is fetched. It will just return an empty response.&lt;/p&gt;
&lt;p&gt;This is where the &lt;code&gt;web.asynchronous&lt;/code&gt; decorator comes in. You decorate the &lt;code&gt;get&lt;/code&gt; method 
with this decorator and Tornado won't terminate the request when &lt;code&gt;get&lt;/code&gt; method exists.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
class MainHandler(web.RequestHandler):
    @web.asynchronous
    def get(self):
        http = AsyncHttpHandler()
        http.fetch("example.com", callback=self.on_response)

    def on_response(self, response):
        # do something with response ...
        self.write(response)
        self.finish()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The updated code will work as expected. One thing to note here is the last line -
&lt;code&gt;self.finish()&lt;/code&gt;. It means you are telling Tornado to terminate the request. If 
you don't write this line, Tornado will keep the request open. You only need to 
use &lt;code&gt;self.finish()&lt;/code&gt; when you're using &lt;code&gt;web.asynchronous&lt;/code&gt; decorator.&lt;/p&gt;
&lt;h4 id="summary_2"&gt;&lt;strong&gt;Summary:&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;web.asynchronous&lt;/code&gt; is used with handler methods (eg. &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, etc.)&lt;/li&gt;
&lt;li&gt;It's used to make handler methods wait and not terminate the request on exit&lt;/li&gt;
&lt;li&gt;You need to manually terminate the request using &lt;code&gt;self.finish()&lt;/code&gt; when using 
 this decorator&lt;/li&gt;
&lt;li&gt;This is useful when using callbacks&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="thats-it"&gt;That's it&lt;/h1&gt;
&lt;p&gt;The things that I've written about in this post were the only things that I found 
most confusing. The other features of Tornado are straight-forward and 
documentation covers them nicely.&lt;/p&gt;
&lt;p&gt;Until next time.&lt;/p&gt;</summary><category term="python"></category><category term="tornado"></category><category term="async"></category></entry><entry><title>Fix the pip error: Couldn't find a version that satisfies the requirement</title><link href="https://bhch.github.io/posts/2017/04/fix-the-pip-error-couldnt-find-a-version-that-satisfies-the-requirement/" rel="alternate"></link><updated>2017-04-13T00:00:00+05:30</updated><author><name>bhch</name></author><id>tag:bhch.github.io,2017-04-13:posts/2017/04/fix-the-pip-error-couldnt-find-a-version-that-satisfies-the-requirement/</id><summary type="html">&lt;p&gt;To skip the background and go to the solution, &lt;a href="#solution"&gt;click here&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="background"&gt;Background&lt;/h1&gt;
&lt;p&gt;I was working on a server recently and I had to install some Python packages. 
What better way to install Python packages other than by using &lt;code&gt;pip&lt;/code&gt;. So, I wrote 
this command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sh
$ pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, it spat out the following error:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Could not find a version that satisfies the requirement &lt;package-name&gt; (from versions:)
No matching distribution found for &lt;package-name&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I tried again, didn't work. Then I searched Google for some help. I found a 
couple of similar questions asked on Stack Overflow. I followed advice there, but 
that didn't help me.&lt;/p&gt;
&lt;p&gt;I kept &lt;em&gt;searching the internet&lt;/em&gt; for almost 2 hours, when I finally gave up. &lt;/p&gt;
&lt;p&gt;Next day, I had to get the server running. So, I decided to install the packages 
from source. I intended to use &lt;code&gt;wget&lt;/code&gt; to download the packages from PyPi. But, 
it gave me a &lt;code&gt;403 Forbidden&lt;/code&gt; error. &lt;/p&gt;
&lt;p&gt;I tried downloading with &lt;code&gt;curl&lt;/code&gt;, but the files it &lt;em&gt;saved&lt;/em&gt; were invalid. It just 
created empty &lt;code&gt;tar.gz&lt;/code&gt; files without actually downloading them.&lt;/p&gt;
&lt;p&gt;I also tried changing my server's DNS. Nothing worked.&lt;/p&gt;
&lt;p&gt;Finally, I though &lt;em&gt;"Let's just see if I can even visit PyPi webpage from this server"&lt;/em&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sh    
$ curl https://pypi.python.org

The requestors Network has been blacklisted due to excessive request volume. 
If you are a hosting customer, please contact your hosting company's support. 
If you are the hosting company, please contact infrastructure-staff@python.org to resolve
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output above shows that my server's IP was blacklisted by &lt;a href="https://python.org"&gt;https://python.org&lt;/a&gt;. 
Well, obviously, because my hosting provider was running many servers 
(virtual servers) behind a single IP. This explains the reason for getting blacklisted. &lt;/p&gt;
&lt;h1 id="solution"&gt;Solution&lt;a name="solution"&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;First let's see the solutions that I tried and &lt;strong&gt;didn't work&lt;/strong&gt; for me:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Changing DNS resolver of my server&lt;/li&gt;
&lt;li&gt;Reconfiguring SSL, reinstalling CA certificates&lt;/li&gt;
&lt;li&gt;Downloading packages using &lt;code&gt;wget&lt;/code&gt;. (Got 403 Forbidden error)&lt;/li&gt;
&lt;li&gt;Downloading packages using &lt;code&gt;curl&lt;/code&gt;. (It just created invalid tarball files, instead of actually downloading them)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Since, all this was happening because &lt;a href="https://python.org"&gt;https://python.org&lt;/a&gt; has blacklisted the IP 
of my hosting provider, the obvious solution was to make &lt;code&gt;pip&lt;/code&gt; install via a proxy. &lt;/p&gt;
&lt;p&gt;Supplying a proxy address to &lt;code&gt;pip&lt;/code&gt; is easy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::sh
$ pip install -r requirements.txt --proxy address:port
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To find proxies, just &lt;a href="https://www.google.com/search?q=proxy+list"&gt;search Google for proxy list&lt;/a&gt;.&lt;/p&gt;</summary><category term="python"></category><category term="pip"></category></entry><entry><title>Hello, World!</title><link href="https://bhch.github.io/posts/2017/03/hello-world/" rel="alternate"></link><updated>2017-03-20T00:00:00+05:30</updated><author><name>bhch</name></author><id>tag:bhch.github.io,2017-03-20:posts/2017/03/hello-world/</id><summary type="html">&lt;p&gt;The mandatory first post.&lt;/p&gt;
&lt;p&gt;I still remember the day when I first decided to learn programming. I was so 
sure of which language I will be learning. The &lt;em&gt;inspiration&lt;/em&gt; to learn Python as 
my first programming language came when I was watching the film 
&lt;em&gt;The Social Network&lt;/em&gt;. In a scene, Mark Zuckerberg mentions 
&lt;em&gt;"... python webserver..."&lt;/em&gt;. Then I went on to search &lt;em&gt;"python"&lt;/em&gt; on Google. 
I read about Python on Wikipedia and other online resources. I was really 
fascinated by the number of applications this language had. Plus, the name is cool.
 It bears an air of mystery about itself.&lt;/p&gt;
&lt;p&gt;Here's the first line of code I ever wrote, and perhaps you did too:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::python
print "Hello, World!"
&lt;/code&gt;&lt;/pre&gt;</summary></entry></feed>